# 10 [模式匹配](../lua.md#10-模式匹配)

与其他几种脚本语言不同，Lua语言既没有使用POSIX正则表达式，也没有使用Perl正则表达式来进行模式匹配(pattern matching)。之所以这样做的主要原因在于大小问题：一个典型的POSIX正则表达式实现需要超过4000行代码，这比所有Lua语言标准库总大小的一半还大。相比之下，Lua语言模式匹配的实现代码只有不到600行。尽管Lua语言的模式匹配做不到完整POSIX实现的所有功能，但是Lua语言的模式匹配仍然非常强大，同时还具有一些与标准POSIX不同但又可与之媲美的功能。

## [模式匹配的相关函数](../lua.md#10-模式匹配)

字符串标准库提供了基于模式(*pattern*)的4个函数。我们已经初步了解过函数find和gsub，其余两个函数分别是match和gmatch(*Global Match*的缩写)。现在让我们学习这几个函数的细节。

### 函数string.find

函数string.find用于在指定的目标字符串中搜索指定的模式。最简单的模式就是一个单词，它只会匹配到这个单词本身。例如，模式'hello'会在目标字符串中搜索子串"hello"。函数string.find找到一个模式后，会返回两个值：匹配到模式开始位置的索引和结束位置的索引。如果没有找到任何匹配，则返回nil：

```lua
s = "hello world"
i, j = string.find(s, "hello")
print(i, j)                         --> 1       5
print(string.sub(s, i, j))          --> hello
print(string.find(s, "world"))      --> 7       11
i, j = string.find(s, "l")
print(i, j)                         --> 3       3 
print(string.find(s, "lll"))        --> nil
```

匹配成功后，可以以函数find返回的结果为参数调用函数string.sub来获取目标字符串中匹配相应模式的子串。对于简单的模式来说，这一般就是模式本身。

函数string.find具有两个可选参数。第3个参数是一个索引，用于说明从目标字符串的哪个位置开始搜索。第4个参数是一个布尔值，用于说明是否进行简单搜索(plain search)。字如其名，所谓简单搜索就是忽略模式而在目标字符串中进行单纯的“查找子字符串”的动作：

```lua
> string.find("a [word]","[") 
stdin:1: malformed pattern (missing ']')
stack traceback:
        [C]: in function 'string.find'
        stdin:1: in main chunk
        [C]: in ?
> string.find("a [word]", "[", 1, true) 
3       3
```

由于'['在模式中具有特殊含义，因此第1个函数调用会报错。在第2个函数调用中，函数只是把'['当作简单字符串。请注意，如果没有第3个参数，是不能传入第4个可选参数的。

### 函数string.match

由于函数string.match也用于在一个字符串中搜索模式，因此它与函数string.find非常相似。不过，函数string.match返回的是目标字符串中与模式相匹配的那部分子串，而非该模式所在的位置：

```lua
print(string.match("hello world", "hello"))     --> hello
```

对于诸如'hello'这样固定的模式，使用这个函数并没有什么意义。然而，当模式是变量时，这个函数的强大之处就显现出来了，例如：

```lua
date = "Todeay is 17/7/1990"
d = string.match(date, "%d+/%d+/%d+")
print(d)    --> 17/7/1990
```

后续，我们会讨论模式'%d+/%d+/%d+'的含义及函数string.match的更高级用法。

### 函数string.gsub

函数string.gsub有3个必选参数：目标字符串、模式和替换字符串(replacementstring)，其基本用法是将目标字符串中所有出现模式的地方换成替换字符串：

```lua
s = string.gsub("Lua is cute", "cute", "great")
print(s)    --> Lua is great
s = string.gsub("all lii", "l", "x")
print(s)    --> axx xii
s = string.gsub("Lua is great", "Sol", "Sun")
print(s)    --> Lua is great
```

此外，该函数还有一个可选的第4个参数，用于限制替换的次数：

```lua
s = string.gsub("all lii", "l", "x", 1)
print(s)    --> axl lii
s = string.gsub("all lii", "l", "x", 2)
print(s)    --> axx lii
```

除了替换字符串以外，string.gsub的第3个参数也可以是一个函数或一个表，这个函数或表会被调用(或检索)以产生替换字符串；我们会在10.4节中学习这个功能。

函数string.gsub还会返回第2个结果，即发生替换的次数。

### 函数string.gmatch

函数string.gmatch返回一个函数，通过返回的函数可以遍历一个字符串中所有出现的指定模式。例如，以下示例可以找出指定字符串s中出现的所有单词：

```lua
s = "some string"
words = {}
for w in string.gmatch(s, "%a+") do
    words[#words + 1] = w
end
```

后续我们马上会学习到，模式'%a+'会匹配一个或多个字母组成的序列(也就是单词)。因此，for循环会遍历所有目标字符串中的单词，然后把它们保存到列表words中。

## [模式](../lua.md#10-模式匹配)

大多数模式匹配库都使用反斜杠(backslash)作为转义符。然而，这种方式可能会导致一些不良的后果。对于Lua语言的解析器而言，模式仅仅是普通的字符串。模式与其他的字符串一样遵循相同的规则，并不会被特殊对待；只有模式匹配相关的函数才会把它们当作模式进行解析。由于反斜杠是Lua语言中的转义符，所以我们应该避免将它传递给任何函数。模式本身就难以阅读，到处把```"\"```换成```"\\"```就更加火上浇油了。

我们可以使用双括号把模式括起来构成的长字符串来解决这个问题(某些语言在实践中推荐这种办法)。然而，长字符串的写法对于通常比较短的模式而言又往往显得冗长。此外，我们还会失去在模式内进行转义的能力(某些模式匹配工具通过再次实现常见的字符串转义来绕过这种限制)。

Lua语言的解决方案更加简单：Lua语言中的模式使用百分号(percent sign)作为转义符(C语言中的一些函数采用的也是同样的方式，如函数printf和函数strftime)。总体上，所有被转义的字母都具有某些特殊含义(例如'%a'匹配所有字母)，而所有被转义的非字母则代表其本身(例如'%.'匹配一个点)。

我们首先来学习字符分类(character class)的模式。所谓字符分类，就是模式中能够与一个特定集合中的任意字符相匹配的一项。例如，分类%d匹配的是任意数字。因此，可以使用模式'%d%d/%d%d/%d%d%d%d'来匹配dd/mm/yyyy格式的日期：

```lua
s = "Deadline is 30/05/1999, firm"
date = "%d%d/%d%d/%d%d%d%d"
print(string.match(s, date))    --> 30/05/1999
```

下表列出了所有预置的字符分类及其对应的含义：

```lua
.           任意字符
%a          字母
%c          控制字符
%d          数字
%g          除空格外的可打印字符
%l          小写字母
%p          标点符号
%s          空白符号
%u          大写字母
%w          字母和数字
%x          十六进制数字
```

这些类的大写形式表示类的补集。例如，'%A'代表任意非字母的字符：

```
print((string.gsub("hello, up-down!", "%A", ".")))  --> hello..up.down.
```

在输出函数gsub的返回结果时，我们使用了额外的括号来丢弃第二个结果，也就是替换发生的次数[^1]。

当在模式中使用时，还有一些被称为魔法字符(magic character)的字符具有特殊含义。Lua语言的模式所使用的魔法字符包括：

```
(   )   .   %   +   -   *   ?   [   ]   ^   $
```

正如我们之前已经看到的，百分号同样可以用于这些魔法字符的转义。因此，'%？'匹配一个问号，'%%'匹配一个百分号。我们不仅可以用百分号对魔法字符进行转义，还可以将其用于其他所有字母和数字外的字符。当不确定是否需要转义时，为了保险起见就可以使用转义符。

可以使用字符集(char-set)来创建自定义的字符分类，只需要在方括号内将单个字符和字符分类组合起来即可。例如，字符集'[%w_]'匹配所有以下画线结尾的字母和数字，'[01]'匹配二进制数字，'[%[%]]'匹配方括号。如果想要统计一段文本中元音的数量，可以使用如下的代码：

```
_, nvow = string.gsub(text, "[AEIOUaeiou]", "")
```

还可以在字符集中包含一段字符范围，做法是写出字符范围的第一个字符和最后一个字符并用横线将它们连接在一起。由于大多数常用的字符范围都被预先定义了，所以这个功能很少被使用。例如，'%d'相当于'[0-9]'，'%x'相当于'[0-9a-fA-F]'。不过，如果需要查找一个八进制的数字，那么使用'[0-7]'就比显式地枚举'[01234567]'强多了。

在字符集前加一个补字符```^```就可以得到这个字符集对应的补集：模式```'[^0-7]'```代表所有八进制数字以外的字符，模式```'[^\n]'```则代表除换行符以外的其他字符。尽管如此，我们还是要记得对于简单的分类来说可以使用大写形式来获得对应的补集：```'%S'```显然要比```'[^%s]'```更简单。

还可以通过描述模式中重复和可选部分的修饰符(modifier，在其他语言中也被译为限定符)来让模式更加有用。Lua语言中的模式提供了4种修饰符：

```
+           重复一次或多次
*           重复零次或多次
-           重复零次或多次(最小匹配)
?           可选(出现零次或一次)
```

修饰符+匹配原始字符分类中的一个或多个字符，它总是获取与模式相匹配的最长序列。例如，模式'%a+'代表一个或多个字母(即一个单词)：

```
print((string.gsub("one, and two; and three", "%a+", "word")))
    --> word, word word; word word
```

模式'%d+'匹配一个或多个数字(一个整数)：

```
print(string.match("the number 1298 is even", "%d+"))   --> 1298
```

修饰符```*```类似于修饰符+，但是它还接受对应字符分类出现零次的情况。该修饰符一个典型的用法就是在模式的部分之间匹配可选的空格。例如，为了匹配像()或()这样的空括号对，就可以使用模式```'%(%s*%)'```，其中的```'%s*'```匹配零个或多个空格(括号在模式中有特殊含义，所以必须进行转义)。另一个示例是用模式```'[_%a][_%w]*'```匹配Lua程序中的标识符：标识符是一个由字母或下画线开头，并紧跟零个或多个由下画线、字母或数字组成的序列。

修饰符-和修饰符*类似，也是用于匹配原始字符分类的零次或多次出现。不过，跟修饰符*总是匹配能匹配的最长序列不同，修饰符-只会匹配最短序列。虽然有时它们两者并没有什么区别，但大多数情况下这两者会导致截然不同的结果。例如，当试图用模式```'[_%a][_%w]-'```查找标识符时，由于```'[_%w]-'```总是匹配空序列，所以我们只会找到第一个字母。又如，假设我们想要删掉某C语言程序中的所有注释，通常会首先尝试使用```'/%*.*%*/'```(即```"/*"```和```"*/"```之间的任意序列，使用恰当的转义符对```*```进行转义)。然而，由于```'.*'```会尽可能长地匹配[^2]，因此程序中的第一个```"/*"```只会与最后一个```"*/"```相匹配：

```
test = "int x; /* x */ int y; /* y */"
print((string.gsub(test, "/%*.*%*/", "")))
    --> int x;
```

相反，模式```'.-'```则只会匹配到找到的第一个```"*/"```，这样就能得到期望的结果：

```
test = "int x; /* x */ int y; /* y */"
print((string.gsub(test, "/%*.-%*/", "")))
    --> int x;  int y;
```

最后一个修饰符？可用于匹配一个可选的字符。例如，假设我们想在一段文本中寻找一个整数，而这个整数可能包括一个可选的符号，那么就可以使用模式'[+-]？%d+'来完成这个需求，该模式可以匹配像"-12"、"23"和"+1009"这样的数字。其中，字符分类'[+-]'匹配加号或减号，而其后的问号则代表这个符号是可选的。

与其他系统不同的是，Lua语言中的修饰符只能作用于一个字符模式，而无法作用于一组分类。例如，我们不能写出匹配一个可选的单词的模式(除非这个单词只由一个字母组成)。通常，可以使用一些将在本章最后介绍的高级技巧来绕开这个限制。

以补字符^开头的模式表示从目标字符串的开头开始匹配。类似地，以$结尾的模式表示匹配到目标字符串的结尾。我们可以同时使用这两个标记来限制匹配查找和锚定(anchor)模式。例如，如下的代码可以用来检查字符串s是否以数字开头：

```
if string.find(s, "^%d") then ...
```

如下的代码用来检查字符串是否为一个没有多余前缀字符和后缀字符的整数：

```
if string.find(s, "^[+-]?%d+$") then ...
```

^和$字符只有位于模式的开头和结尾时才具有特殊含义；否则，它们仅仅就是与其自身相匹配的普通字符。

模式'%b'匹配成对的字符串，它的写法是'%bxy'，其中x和y是任意两个不同的字符，x作为起始字符而y作为结束字符。例如，模式'%b()'匹配以左括号开始并以对应右括号结束的子串：

```
s = "a (enclosed (in) parentheses) line"
print((string.gsub(s, "%b()", "")))     -->a  line
```

通常，我们使用'%b()'、'%b[]'、'%b{}'或'%b<>'等作为模式，但实际上可以用任意不同的字符作为分隔符。

最后，模式'%f[char-set]'代表前置模式(frontier pattern)。该模式只有在后一个字符位于char-set内而前一个字符不在时匹配一个空字符串[^3]：

```
s = "the anthem is the theme"
print((string.gsub(s, "%f[%w]the%f[%W]", "one")))
    --> one anthem is one theme
```

模式'%f[%w]'匹配位于一个非字母或数字的字符和一个字母或数字的字符之间的前置，而模式'%f[%W]'则匹配一个字母或数字的字符和一个非字母或数字的字符之间的前置。因此，指定的模式只会匹配完整的字符串"the"[^4]。请注意，即使字符集只有一个分类，也必须把它用括号括起来。

前置模式把目标字符串中第一个字符前和最后一个字符后的位置当成空字符(ASCII编码的\0)。在前例中，第一个"the"在不属于集合'[%w]'的空字符和属于集合'[%w]'的t之间匹配了一个前置。

## [捕获](../lua.md#10-模式匹配)

捕获(capture)机制允许根据一个模式从目标字符串中抽出与该模式匹配的内容来用于后续用途，可以通过把模式中需要捕获的部分放到一对圆括号内来指定捕获。

对于具有捕获的模式，函数string.match会将所有捕获到的值作为单独的结果返回；换句话说，该函数会将字符串切分成多个被捕获的部分：

```
pair = "name = Anna"
key, value = string.match(pair, "(%a+)%s*=%s*(%a+)")
print(key, value)   --> name    Anna
```

模式'%a+'表示一个非空的字母序列，模式'%s*'表示一个可能为空的空白序列。因此，上例中的这个模式表示一个字母序列、紧跟着空白序列、一个等号、空白序列以及另一个字母序列。模式中的两个字母序列被分别放在圆括号中，因此在匹配时就能捕获到它们。下面是一个类似的示例：

```
date = "Today is 17/7/1990"
d, m, y = string.match(date, "(%d+)/(%d+)/(%d+)")
print(d, m, y)      -->17      7       1990
```

在这个示例中，使用了3个捕获，每个捕获对应一个数字序列。

在模式中，形如'%n'的分类(其中n是一个数字)，表示匹配第n个捕获的副本。举一个典型的例子，假设想在一个字符串中寻找一个由单引号或双引号括起来的子串。那么可能会尝试使用模式'["'].-["']'，它表示一个引号后面跟任意内容及另外一个引号；但是，这种模式在处理像"it's all right"这样的字符串时会有问题。要解决这个问题，可以捕获第一个引号然后用它来指明第二个引号：

```
s = [[then he said: "it's all right"!]]
q, quotedPart = string.match(s, "([\"'])(.-)%1")
print(quotedPart)   --> it's all right
print(q)            --> "
```

第1个捕获是引号本身，第2个捕获是引号中的内容(与'.-'匹配的子串)。

下例是一个类似的示例，用于匹配Lua语言中的长字符串的模式：

```
%[(=*)%[(.-)%]%1%]
```

它所匹配的内容依次是：一个左方括号、零个或多个等号、另一个左方括号、任意内容(即字符串的内容)、一个右方括号、相同数量的等号及另一个右方括号：

```
p = "%[(=*)%[(.-)%]%1%]"
s = "a = [=[[[ somrthing ]] ]==] ]=];print(a)"
print(string.match(s, p))   --> =       [[ somrthing ]] ]==]
```

第1个捕获是等号序列(在本例中只有一个)，第2个捕获是字符串内容[^5]。

被捕获对象的第3个用途是在函数gsub的替代字符串中。像模式一样，替代字符串同样可以包括像"%n"一样的字符分类，当发生替换时会被替换为相应的捕获。特别地，"%0"意味着整个匹配，并且替换字符串中的百分号必须被转义为"%%"。下面这个示例会重复字符串中的每个字母，并且在每个被重复的字母之间插入一个减号：

```
print((string.gsub("hello Lua!", "%a", "%0-%0")))
    --> h-he-el-ll-lo-o L-Lu-ua-a!
```

下例交换了相邻的字符：

```
print((string.gsub("hello Lua", "(.)(.)", "%2%1")))
    --> ehll ouLa
```

以下是一个更有用的示例，让我们编写一个原始的格式转换器，该格式转换器能读取LATEX风格的命令，并将它们转换成XML风格：

```
\command{some text}   -->   <command>some text</command>
```

如果不允许嵌套的命令，那么以下调用函数string.gsub的代码即可完成这项工作：

```
s = [[the \quote{task} is to \em{change} that.]]
s = string.gsub(s, "\\(%a+){(.-)}", "<%1>%2<%1>")
print(s)
    --> the <quote>task<quote> is to <em>change<em> that.
```

(在下一节中，我们将会学习如何处理嵌套的命令。)

另一个有用的示例是剔除字符串两端空格：

```
function trim(s)
    s = string.gsub(s, "^%s*(.-)%s*$", "%1")
    return s
end
```

请注意模式中修饰符的合理运用。两个定位标记(^和$)保证了我们可以获取到整个字符串。由于中间的'.-'只会匹配尽可能少的内容，所以两个'%s*'便可匹配到首尾两端的空格。

## [替换](../lua.md#10-模式匹配)

正如我们此前已经看到的，函数string.gsub的第3个参数不仅可以是字符串，还可以是一个函数或表。当第3个参数是一个函数时，函数string.gsub会在每次找到匹配时调用该函数，参数是捕获到的内容而返回值则被作为替换字符串。当第3个参数是一个表时，函数string.gsub会把第一个捕获到的内容作为键，然后将表中对应该键的值作为替换字符串。如果函数的返回值为nil或表中不包含这个键或表中键的对应值为nil，那么函数gsub不改变这个匹配。

先举一个例子，下述函数用于变量展开(variable expansion)，它会把字符串中所有出现的$varname替换为全局变量varname的值：

```
function expand(s)
    return (string.gsub(s, "$(%w+", _G))
end

name = "Lua";
status = "great"
print(expand("$name is $status, isn't it"))
    --> Lua is great, isn't it
```

(_G是预先定义的包括所有全局变量的表，我们会在第22章中讨论相关细节。)对于每个与'\$(%w+)'匹配的地方($符号后紧跟一个名字)，函数gsub都会在全局表_G中査找捕获到的名字，并用找到的结果替换字符串中相匹配的部分；如果表中没有对应的键，则不进行替换：

```
print(expand("$othername is $status, isn't it"))
    --> $othername is great, isn't it
```

如果不确定是否指定变量具有字符串值，那么可以对它们的值调用函数tostring。在这种情况下，可以用一个函数来返回要替换的值：

```
function expand(s)
    return (string.gsub(s, "$(%w+)", function(n)
        return tostring(_G[n])
    end))
end

print(expand("print = $print; a = $a"))
    --> paint = function: 0000000065b9cff0; a = nil
```

在函数expand中，对于所有匹配'$(%w+)'的地方，函数gsub都会调用给定的函数，传入捕获到的名字作为参数，并使用返回字符串替换匹配到的内容。

最后一个例子，让我们再回到上一节中提到的格式转换器。我们仍然是想将LATEX风格的命令(```\example{text}```)转换成XML风格的(```<example>text</example>```)，但这次允许嵌套的命令。以下的函数用递归的方式完成了这个需求：

```
function toxml(s)
    s = string.gsub(s, "\\(%a+)(%b{})", function(tag, body)
        body = string.sub(body, 2, -2)
        body = toxml(body)
        return string.format("<%s>%s<%s>", tag, body, tag)
    end)
    return s
end

print(toxml("\\title{The \\bold{big} example}"))
    --> <title>The <bold>big<bold> example<title>
```

### URL编码

我们的下一个示例中将用到URL编码，也就是HTTP所使用的在URL中传递参数的编码方式。这种编码方式会将特殊字符(例如=、＆和+)编码为"%xx"的形式，其中xx是对应字符的十六进制值。此外，URL编码还会将空格转换为加号。例如，字符串"a+b=c"的URL编码为"a%2Bb+%3D+c"。最后，URL编码会将每对参数名及其值用等号连接起来，然后将每对name=value用＆连接起来。例如，值

```
name = "al"; query = "a + b = c"; q = "yes or no"
```

对应的URL编码为```"name=al＆query=a%2Bb+%3D+c＆q=yes+or+no"```。

现在，假设要将这个URL解码并将其中的键值对保存到一个表内，以相应的键作为索引，那么可以使用以下的函数完成基本的解码：

```
function unescape(s)
    s = string.gsub(s, "+", " ")
    s = string.gsub(s, "%%(%x%x)", function(h)
        return string.char(tonumber(h, 16))
    end)
    return s
end

print(unescape("a%2Bb+%3D+c"))  --> a+b = c
```

第一个gsub函数将字符串中的所有加号替换为空格，第二个gsub函数则匹配所有以百分号开头的两位十六进制数，并对每处匹配调用一个匿名函数。这个匿名函数会将十六进制数转换成一个数字(以16为进制，使用函数tonumber)并返回其对应的字符(使用函数string.char)。

可以使用函数gmatch来对键值对name=value进行解码。由于键名和值都不能包含＆或=，所以可以使用模式'[^＆=]+'来匹配它们：

```
cgi = {}
function decode(s)
    for name, value in string.gmatch(s, "([^&=]+)=([^&=]+)") do
        name = unescape(name)
        value = unescape(value)
        cgi[name] = value
    end
end
```

调用函数gmatch会匹配所有格式为name=value的键值对。对于每组键值对，迭代器会返回对应的捕获(在匹配的字符串中被括号括起来了)，捕获到的内容也就是name和value的值。循环体内只是简单地对两个字符串调用函数unescape，然后将结果保存到表cgi中。

对应的编码函数也很容易编写。先写一个escape函数，用它将所有的特殊字符编码为百分号紧跟对应的十六进制形式(函数format的参数"%02X"用于格式化输出一个两位的十六进制数，若不足两位则以0补齐)，然后把空格替换成加号：

```
function escape(s)
    s = string.gsub(s, "[&=+%%%c]", function(c)
        return string.format("%%%02X", string.byte(c))
    end)
    s = string.gsub(s, " ", "+")
    return s
end
```

encode函数会遍历整个待编码的表，然后构造出最终的字符串：

```
function encode(t)
    local b = {}
    for k, v in pairs(t) do
        b[#b + 1] = (escape(k) .. "=" .. escape(v))
    end
    -- 将'b'中所有的元素使用"&"连接在一起
    return table.concat(b, "&")
end

t = {name = "a1", query = "a+b = c", q = "yes or no"}
print(encode(t))    --> q=yes+or+no&name=a1&query=a%2Bb+%3D+c
```

### 制表符展开

在Lua语言中，像'()'这样的空白捕获(empty capture)具有特殊含义。该模式并不代表捕获空内容(这样的话毫无意义)，而是捕获模式在目标字符串中的位置(该位置是数值)：

```
print(string.match("hello", "()ll()"))  --> 3       5
```

(请注意，由于第2个空捕获的位置是在匹配之后，所以这个示例的结果与调用函数string.find得到的结果并不一样。)

另一个关于位置捕获(position capture)的良好示例是在字符串中进行制表符展开：

```
function expandTabs(s, tab)
    tab = tab or 8      -- 制表符的"大小"(默认是8)
    local corr = 0      -- 修正量
    s = string.gsub(s, "()\t", function(p)
        local sp = tab - (p - 1 + corr) % tab
        corr = corr - 1 + sp
        return string.rep(" ", sp)
    end)
    return s
end
```

函数gsub会匹配字符串中所有的制表符并捕获它们的位置。对于每个制表符，匿名函数会根据其所在位置计算出需要多少个空格才能恰好凑够一列(整数个tab)：该函数先将位置减去1以从0开始计数，然后加上corr凑整之前的制表符(每一个被展开的制表符都会影响后续制表符的位置)。之后，该函数更新下一个制表符的修正量：为正在被去掉的制表符减1，再加上要增加的空格数sp。最后，这个函数返回由替代制表符的合适数量的空格组成的字符串。

为了完整起见，让我们再看一下如何实现逆向操作，即将空格转换为制表符。第一种方法是通过空捕获来对位置进行操作，但还有一种更简单的方法：即在字符串中每隔8个字符插入一个标记，然后将前面有空格的标记替换为制表符。

```
function unexpandTabs(s, tab)
    tab = tab or 8
    s = expandTabs(s, tab)
    local pat = string.rep(".", tab)    -- 辅助模式
    s = string.gsub(s, pat, "%0\1")     -- 在每8个字符后添加一个标记\1
    s = string.gsub(s, "+\1", "+\1")     -- 将所有以此标记结尾的空格序列都替换为制表符\t
    s = string.gsub(s, "\1", "")
    return s
end
```

这个函数首先对字符串进行了制表符展开以移除其中所有的制表符，然后构造出一个用于匹配所有8个字符序列的辅助模式，再利用这个模式在每8个字符后添加一个标记(控制字符\1)。接着，它将所有以此标记结尾的空格序列都替换为制表符。最后，将剩下的标记删除(即那些没有位于空格后的标记)。

## [诀窍](../lua.md#10-模式匹配)

模式匹配是进行字符串处理的强大工具之一。虽然通过多次调用函数string.gsub就可以完成许多复杂的操作，但是还是应该谨慎地使用该函数。

模式匹配替代不了传统的解析器。对于那些用后即弃的程序来说，我们确实可以在源代码中做一些有用的操作，但却很难构建出高质量的产品。例如，考虑一下之前曾经用来匹配C语言程序中注释的模式```'/%*.-%*/'```。如果C代码中有一个字符串常量含有```"/*"```，那么就会得到错误的结果：

```
test = [[char s[] = "a/* here"; /* a tricky string */]]
print((string.gsub(test, "/%*.-%*/", "<COMMENT>")))
    --> char s[] = "a<COMMENT>
```

由于含有注释标记的字符串十分少见，因此对于我们自用的程序而言，这个模式可能能够满足需求；但是，我们不应该将这个带有缺陷的程序发布出去。

通常，在Lua程序中使用模式匹配时的效率是足够高的：笔者的新机器可以在不到0.2秒的时间内计算出一个4.4MB大小(具有85万个单词)的文本中所有单词的数量。[^6]但仍然需要注意，应该永远使用尽可能精确的模式，不精确的模式会比精确的模式慢很多。一个极端的例子是模式```'(.-)%$'```，它用于获取字符串中第一个```$```符号前的所有内容。如果目标字符串中有```$```符号，那么这个模式工作很正常；但是，如果字符串中没有```$```符号，那么模式匹配算法就会首先从字符串起始位置开始匹配，直至为了搜索```$```符号而遍历完整个字符串。当到达字符串结尾时，这次从字符串起始位置开始的模式匹配就失败了。之后，模式匹配算法又从字符串的第二个位置开始第二次搜索，结果仍然是无法匹配这个模式。这个匹配过程会在字符串的每个位置上进行一次，从而导致O(n<sup>2</sup>)的时间复杂度。在笔者的新机器上，搜索20万个字符需要耗费超过4分钟的时间。要解决这个问题，我们只需使用```'^(.-)%$'```将模式锚定在字符串的开始位置即可。这样，如果不能从起始位置开始找到匹配，搜索就会停止。有了^的锚定以后，该模式匹配就只需要不到0.01秒的时间了。

此外，还要留心空模式，也就是那些匹配空字符串的模式。例如，如果试图使用模式'%a*'来匹配名字，那么就会发现到处都是名字：

```
i, j = string.find(";$%  **#$hello13", "%a*")
print(i, j)     --> 1       0
```

在这个示例中，函数string.find在字符串的开始位置正确地找到一个空的字母序列。

在模式的结束处使用修饰符-是没有意义的，因为这样只会匹配到空字符串。该修饰符总是需要在其后跟上其他的东西来限制扩展的范围。同样，含有'.*'的模式也非常容易出错，这主要是因为这种模式可能会匹配到超出我们预期范围的内容。

有时，用Lua语言来构造一个模式也很有用。我们已经在将空格转换为制表符的程序中使用过这个技巧。接下来再看另外一个示例，考虑如何找出一个文本中较长的行(比如超过70个字符的行)。较长的行就是一个具有70个或更多字符的序列，其中每个字符都不为换行符，因而可以用字符分类'[^\n]'来匹配除换行符以外的其他单个字符。这样，就能够通过把这个匹配单个字符的模式重复70次来匹配较长的行。除了手写以外，还可以使用函数string.rep来创建这个模式：

```
pattern = string.rep("[^\n]", 70) .. "+"
```

再举一个例子，假设要进行大小写无关的查找。一种方法就是将模式中的所有字母x用'[xX]'替换，即同时包含原字母大小写形式的字符分类。我们可以使用如下函数来自动地完成这种转换：

```
function nocase(s)
    s = string.gsub(s, "%a", function(c)
        return "[" .. string.lower(c) .. string.upper(c) .. "]"
    end)
    return s
end

print(nocase("Hi there!"))  -->[hH][iI] [tT][hH][eE][rR][eE]!
```

有时，我们可能需要将所有出现的s1替换为s2，而不管其中是否包含魔法字符。如果字符串s1和s2是常量，那么可以在编写字符串时对魔法字符进行合理的转义；但如果字符串是一个变量，那么就需要用另一个gsub函数来进行转义：

```
s1 = string.gsub(s1, "(%W)", "%%%1")
s2 = string.gsub(s2, "%%", "%%%%")
```

在进行字符串搜索时，我们对所有字母和数字外的字符进行了转义(即大写的W)。而在替换字符串中，我们只对百分号进行了转义。

模式匹配的另一个有用的技巧就是，在进行实际工作前先对目标字符串进行预处理。假设想把一个字符串中所有被双引号(")引起来的内容改为大写，但又允许内容中包含转义的引号```("\"")```：

```
follows a typical string: "This is \"great\"!".
```

处理这种情况的方法之一就是先对文本进行预处理，将所有可能导致歧义的内容编码成别的内容。例如，可以将```"\""```编码为"\1"。不过，如果原文中本身就含有"\1"，那么就会遇到问题。另一种可以避免这个问题的简单做法是将所有"\x"编码为"\ddd"，其中ddd为字符x的十六进制表示形式：

```
function code(s)
    return (string.gsub(s, "\\(.)", function(x)
        return string.format("\\%03d", string.byte(x))
    end))
end
```

这样，由于原字符串中所有的"\ddd"都进行了编码，所以编码后字符串中的"\ddd"序列一定都是编码造成的。这样，解码也就很简单了：

```
function decode(s)
    return (string.gsub(s, "\\(%d%d%d)", function(d)
        return "\\" .. string.char(tonumber(d))
    end))
end
```

现在我们就可以完成把一个字符串中被双引号(")引起来的内容改为大写的需求。由于编码后的字符串中不包含任何转义的引号```("\"")```，所以就可以直接使用```'".-"'```来查找位于一对引号中的内容：

```
s = [[follows a typical string: "This is \"great\"!".]]
s = code(s)
s = string.gsub(s, '".-"', string.upper)
s = decode(s)
print(s)    --> follows a typical string: "THIS IS \"GREAT\"!".
```

或者写成：

```
print(decode(string.gsub(code(s), '".-"', string.upper)))
```

是否能够将模式匹配函数用于UTF-8字符串取决于模式本身。由于UTF-8的主要特性之一就是任意字符的编码不会出现在别的字符的编码中，因此文本类的模式一般可以正常工作。字符分类(character class)和字符集(character set)只对ASCII字符有效。例如，可以对UTF-8字符串使用模式'%s'，但它只能匹配ASCII空格，而不能匹配诸如HTML空格(即＆nbsp;，NBSP，Non-Break Space，U+00A0)或蒙古文元音分隔符(mongolian vowel separator，U+180E)等其他的Unicode空格。

恰当的模式能够为处理Unicode带来额外的能力。一个优秀的例子是预定义模式utf8.charpattern，该模式只精确地匹配一个UTF-8字符。utf8标准库中就是按照下面的方法定义这个模式的：

```
utf8.charpattern=[\0-\x7F\xC2-\xF4][\x80-\xBF]*
```

该模式的第1部分匹配ASCII字符(范围[0,0x7F])或多字节序列的起始字节(范围[0xC2,0xF4])，第2部分则匹配零个或多个后续的字节(范围[0x80,0xBF])。

## [练习](../lua.md#10-模式匹配)

练习10.1：请编写一个函数split，该函数接收两个参数，第1个参数是字符串，第2个参数是分隔符模式，函数的返回值是分隔符分割后的原始字符串中每一部分的序列：

```
t = split("a whole new world", " ")
-- t = {"a", "whole", "new", "world"} 
```

你编写的函数是如何处理空字符串的呢？特别是，一个空字符串究竟是空序列(anempty sequence)，还是一个具有空字符串的序列(a sequence with one empty string)呢？

练习10.2：模式```'%D'```和```'[^%d]'```是等价的，那么模式```'[^%d%u]'和'[%D%U]'```呢？

练习10.3：请编写一个函数transliterate，该函数接收两个参数，第1个参数是字符串，第2个参数是一个表。函数transliterate根据第2个参数中的表使用一个字符替换字符串中的字符。如果表中将a映射为b，那么该函数则将所有a替换为b。如果表中将a映射为false，那么该函数则把结果中的所有a移除。

练习10.4：在10.3节的最后，我们定义了一个trim函数。由于该函数使用了回溯，所以对于某些字符串来说该函数的时间复杂度是O(n<sup>2</sup>)。例如，在笔者的新机器上，针对一个100KB大小字符串的匹配可能会耗费52秒。
•构造一个可能会导致函数trim耗费O(n<sup>2</sup>)时间复杂度的字符串。
•重写这个函数使得其时间复杂度为O(n)。

练习10.5：请使用转义序列\x编写一个函数，将一个二进制字符串格式化为Lua语言中的字符串常量：

```
print(escape("\0\1hello\200"))
    --> \x00\x01\x68\x65\x6C\x6C\x6F\xC8
```

作为优化，请同时使用转义序列\z打破较长的行。

练习10.6：请为UTF-8字符重写函数transliterate。

练习10.7：请编写一个函数，该函数用于逆转一个UTF-8字符串。

[^1]:译者注：如果只用一个括号则还会输出替换发生的次数，也就是4。
[^2]:译者注：在标准正则表达式中即为贪婪匹配。
[^3]:译者注：原文中前置模式的解释不够充分，实际上在http://lua-users.org/wiki/FrontierPattern中对此有额外说明，即The frontier pattern%f followed by a set detects the transition from“not in set”to“in set”。
[^4]:译者注：不会匹配到上例中anthem中的the或theme中的the。
[^5]:译者注：%n表示匹配第n个捕获的副本，在本例中的第一个捕获就是若干个等号组成的序列，因此%1相当于匹配这若干个等号。
[^6]:“笔者的新机器”是内存为8GB，CPU主频为3.6GHz的Intel Core i7-4790。本书中所有的性能测试数据都是从这台机器上得来的。
